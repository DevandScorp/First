/**
 * Когда функция вызывается с указанием перед ней new,также известный как вызов конструктора,автоатически выполняются следующие вещи:
 * 1.Создается новый объект
 * 2.Только что сконструированный объект связывается с прототипом
 * 3.Только что сконструированный объект устанавливается как привязка this для этого прототипа функции
 * 4.За исключением тех случаев,когда функция возвращает свой собственный альтернативный объект,вызов функции с new автоматически вернет
 * только что сконструированный объект
 */
function f(a) {
    this.a = a;
}
var b = new f(2);
console.log(b.a);
/**
 * Что должно идти раньше: явная привязка или неявная привязка?
 */
function foo(){
    console.log(this.a);
}
var obj1 = {
    a:2,
    foo:foo
}
var obj2 = {
    a:3,
    foo:foo
}
obj1.foo();//2
obj2.foo();//3
obj1.foo.call(obj2);//3
obj2.foo.call(obj1);//2
/**Явная привязка имеет приоритет над неявной*/
/**А что по new*/
console.log("____________________________________________________________");
function f1(smth){
    this.a = smth;
}
var obj3 = {
    f1:f1
}
var obj2 = {};
obj3.f1(2);
console.log(obj3.a);//2
obj3.f1.call(obj2,3);
console.log(obj2.a);//3
var bar = new obj3.f1(4);
console.log(obj3.a);//2
console.log(bar.a);//4
/**А что по жесткой привязке и new*/
console.log("____________________________________________________________");
function f2(smth){
    this.a = smth;
}
var obj4 = {};
var bar = f2.bind(obj4);//жесткая привязка
/**
 * bind - создаёт "обёртку" над функцией, которая подменяет контекст этой функции.
 * Поведение похоже на call и apply, но,
 * в отличие от них, bind не вызывает функцию,
 * а лишь возвращает "обёртку", которую можно вызвать позже.
 */
bar(2);
console.log(obj4.a);//2

var baz = new bar(3);
console.log(obj4.a);//2
console.log(baz.a);//3